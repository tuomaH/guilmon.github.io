### 1.1. R语言入门

#### **1.1.1 R语言简介与历史**
*  **起源**: R语言是S编程语言的一种实现，在许多方面都优于原始的S系统 。S语言是由John M. Chambers等人在20世纪70年代末至80年代初于贝尔实验室开发的统计编程语言。
*  **开发者**: R最初由新西兰奥克兰大学的研究员Ross Ihaka和Robert Gentleman编写，现在由R核心团队进行维护。
* **核心特性**:
    *  **免费与开源**: R是免费软件，您可以免费获取它，并且其源代码是公开的 。这意味着用户可以研究其内部工作原理并根据需要进行修改。
    *  **可扩展性**: R是可扩展的，用户可以从CRAN（Comprehensive R Archive Network）获取大量的扩展包 。目前有超过15,000个扩展包可用。

#### **1.1.2 为何使用R？**
*  **行业地位**: R与Python是当今统计学和数据科学领域的关键平台。
*  **功能强大**: R拥有一个非常优秀的图形引擎和海量的扩展包，几乎涵盖了所有的统计方法。
* **灵活性**:
    *  R是一个命令行程序，通过键入命令来控制 。虽然这看起来“老式”，但对于可执行数十万种不同任务的R来说，菜单驱动的图形界面（GUI）是不切实际的 。
    *  与菜单驱动的软件相比，命令行程序更加灵活，您可以通过编写自己的程序来完成前人未曾想过或做过的事情 。
*  **学习编程的基石**: 编程语言之间非常相似  。掌握了R语言编程后，学习其他语言（如C, C++, Java, Python等）会变得容易得多 。

#### **1.1.3 R语言的技术特性**
*  **解释型语言 (Interpreted Language)**: R代码是逐行执行的，无需像C或Java那样先进行“编译”  。这使得调试过程更简单，因为代码可以交互式地逐行运行  。不过，这通常会带来性能上的损失，编译型语言速度更快  。为了弥补这一点，R中的许多操作（如矩阵乘法）底层是用Fortran或C实现的 。
*  **动态类型语言 (Dynamically-typed Language)**: 与C++或Java不同，R不需要在使用变量前声明其类型 。
*  **面向对象 (Object-Oriented)**: 在R中，数据结构的行为会因其类型而异  。例如，`summary()`方法会根据对象的类型提供不同的摘要信息，`plot()`方法会根据对象类型绘制不同的图形 。
*  **垃圾回收 (Garbage-Collected)**: R会自动管理内存  。不再被引用的对象会被自动从内存中移除（即“垃圾回收”） 。

---

### 1.2. R与RStudio的安装和使用

#### **1.2.1 软件安装**
*  **安装R**: 您可以从CRAN ([https://cran.r-project.org/](https://cran.r-project.org/)) 免费下载标准版的R  。R支持Windows, Mac OS和Linux等多个平台 。
*  **安装RStudio**: 强烈建议安装RStudio Desktop，它是一个功能强大的R集成开发环境（IDE） 。
    *  **优势**: RStudio拥有一个更强大的代码编辑器，具备语法高亮等功能，使代码更易读 。
    *  **前提**: RStudio只是R的一个前端界面，因此必须先安装R才能使用RStudio 。
    *  **下载**: 您可以从RStudio官网 ([https://www.rstudio.com/products/rstudio/download/](https://www.rstudio.com/products/rstudio/download/)) 免费下载开源桌面版 。

#### **1.2.2 RStudio界面与使用**
* **基本布局**:
    *  **左上**: **脚本编辑器 (Editor)**，建议在此处编写R命令 。
    *  **左下**: **控制台 (Console)**，可以直接输入命令，但更推荐使用编辑器 。
    *  **右上**: **环境/历史 (Environment/History)**，显示当前工作区中的对象列表和历史命令 。
    *  **右下**: **文件/绘图/包/帮助 (Files/Plots/Packages/Help)**，分别用于显示文件、图形、已安装的包和帮助文档 。
*  **执行代码**: 在编辑器中选中要运行的命令，然后点击"Run"按钮或按`Ctrl-Enter`键 。
* **实用功能**:
    *  **语法高亮**: 代码根据R的语法规则自动显示不同颜色，便于阅读 。
    *  **括号匹配**: 输入一个闭合括号时，对应的开放括号会被高亮显示 。
    *  **自动补全**: 输入函数或变量名时，按`Tab`键可以自动补全或显示选项菜单 。
    *  **快速帮助**: 输入函数名后按`F1`键，可以打开该函数的帮助文档 。

#### **1.2.3 R包 (Packages)**
*  **作用**: R包是“附加组件”，提供了R基础功能之外的扩展功能 。
* **安装包**:
    *  使用命令: 在控制台输入 `install.packages("包的名称")`  。例如，`install.packages("mgcv")`  。这会自动下载并安装该包及其所有依赖项 。
    *  使用界面: 在右下角的"Packages"标签页中点击"Install" 。
*  **加载包**: 安装后，必须使用 `library(包的名称)` 命令加载包，才能使用其中的函数 。
*  **常见错误**: 如果运行 `library()` 时出现 "there is no package called 'somepackage'" 的错误，说明该包尚未安装，需要先进行安装 。

---

### 1.3. R的计算能力与局限性

#### **1.3.1 强大的计算能力**
*  现代计算机的计算能力和数据存储技术的进步是数据科学崛起的驱动力 。
* **示例**:
    *  **矩阵乘法**: 一个中端i5处理器在R中计算两个 $1000 \times 1000$ 矩阵的乘法仅需不到一秒钟  。而一个“人类计算机”以每秒一次浮点运算的速度计算，需要超过32年 。
    *  **排序**: R对一百万个数值进行排序，也仅需不到一秒钟的时间 。

#### **1.3.2 计算机的计算局限性**
*  **不要盲目信任**: 计算机并非绝对可靠，它们只有有限的精度，我们不应盲目相信其计算结果 。
* **浮点数精度问题**:
    *  **加法交换律失效**: 在R中，`10^20 - 10^20 + 1` 的结果是1，但 `1 + 10^20 - 10^20` 的结果却是0  。这是因为计算机认为 $1+10^{20} \approx 10^{20}$，因为1相对于 $10^{20}$ 来说太小而被忽略了 。
    *  **二进制表示误差**: 计算机内部大多使用二进制系统  。像0.1或0.3这样的数在二进制中没有精确的有限表示，会导致舍入误差  。因此，`0.1 + 0.1 + 0.1 - 0.3` 的结果不是0，而是一个非常接近0的小数 。
* **IEEE 754标准**:
    *  R使用IEEE 754双精度浮点数来表示数字 。
    *  **溢出 (Overflow)**: 当计算结果超过计算机能表示的最大数（约 $1.7977 \cdot 10^{308}$）时，会发生溢出  。在R中，结果会被设为 `Inf` (无穷大) 。
    *  **特殊值**: R支持 `Inf`, `-Inf` 和 `NaN` (Not a Number，不是一个数) 等特殊值  。例如，`1/0` 结果为 `Inf`  ，而 `Inf / Inf` 结果为 `NaN`  。`sqrt(-1)` 也会产生 `NaN` 。

---

### 1.4. R的基础语法

#### **1.4.1 R作为计算器**
* **基本算术运算符**:
| 运算符 | 含义 | 示例 | 结果 |
| :--- | :--- | :--- | :--- |
| `+` | 加法 | `3+2` | 5 |
| `-` | 减法 | `3-2` | 1 |
| `*` | 乘法 | `3*2` | 6 |
| `/` | 除法 | `5/2` | 2.5 |
| `^` 或 `**` | 幂运算 | `5^2` | 25 |
| `%/%` | 整除 | `5%/%2` | 2 |
| `%%` | 取余 | `5%%2` | 1 |
*  **运算符优先级**: R遵循特定的运算顺序：首先是 `^`，然后是 `*` 和 `/`，最后是 `+` 和 `-`  。当优先级相同时，从左到右计算。为了控制运算顺序，应使用括号 `()` 。
*  **数学函数与常量**: R内置了大量数学函数，如 `sqrt()` (平方根), `exp()` (指数), `log()` (对数), `sin()` (正弦)等  。常量 $pi$ 可以通过 `pi` 直接使用 。

#### **1.4.2 变量与赋值**
*  **赋值操作**: 为了重用计算结果，需要将其赋值给一个变量 。
    *  R中首选的赋值符号是 `<-`  。例如：`a <- 2/3*2` 。
    *  虽然 `=` 也可以使用，但在某些情况下与 `<-` 不同 。
* **变量命名**:
    *  变量名区分大小写，`a` 和 `A` 是两个不同的变量 。
    *  传统上，R用户习惯用小写字母，并用点 `.` 分隔单词 (如 `two.words`)，但下划线 `_` 也越来越流行 。
*  **使用变量**: 要查看变量的值，只需在控制台输入变量名即可  。赋值操作是即时的，后续改变原变量的值不会影响已赋值的新变量  。例如，执行 `a <- 10`，然后 `b <- a/5`，之后再执行 `a <- a + 30`，`b` 的值仍然是2 。
*  **查看变量**: 使用 `ls()` 命令可以列出当前工作区中的所有变量 。

#### **1.4.3 逻辑变量与比较**
*  **逻辑值**: 逻辑变量只能取 `TRUE` (真) 或 `FALSE` (假) 这两个值 。
* **逻辑运算符**:
    *  `!` (逻辑非，NOT) 
    *  `&` (逻辑与，AND) 
    *  `|` (逻辑或，OR) 
    *  **优先级**: `&` 的优先级高于 `|` 。
    *  **惰性求值**: `&&` 和 `||` 是“惰性”运算符，仅在需要时才评估第二个表达式，通常用于 `if` 条件判断，不应用于向量 。
*  **慎用 `T` 和 `F`**: 虽然可以用 `T` 和 `F` 分别代表 `TRUE` 和 `FALSE`，但强烈不推荐这样做。因为 `T` 和 `F` 是可以被用户重新赋值的变量，可能会导致意外的错误。
* **比较运算符**:
    *  包括 `==` (等于), `!=` (不等于), `<`, `<=`, `>`, `>=` 。
    *  这些运算符返回一个逻辑值 (`TRUE` 或 `FALSE`) 。
*  **比较浮点数**: 由于舍入误差，不应使用 `==` 来直接比较非整数  。例如，`0.3 - 2 * 0.1 == 0.1` 在R中返回 `FALSE` 。正确的做法是判断两个数的绝对差是否小于一个极小的阈值（如 $10^{-8}$） ，或者使用 `all.equal()` 函数 。


### 2.1. R中的向量 (Vectors)

#### **2.1.1 向量的基本概念**
* 在R中，所有变量本质上都是向量 。
* 我们通常所说的标量（只包含一个值的变量）在R中实际上是长度为1的向量 。

#### **2.1.2 创建与合并向量**
* **创建向量**: 创建向量最简单的方法是使用 `c()` 函数 。
    * 例如：`a <- c(1, 4, 2)` 。
* **合并向量 (Concatenate)**: 同样可以使用 `c()` 函数将两个或多个向量“粘”在一起 。
    * 例如：`c(a, b)` 会将向量a和b合并成一个新向量 。
* **命名向量元素**:
    * 可以为向量的每个元素赋予名称，这在处理有实际意义的数据时非常有用 。
    * **方法一**: 使用 `names()` 函数进行赋值 。
        * `names(a) <- c("first", "second", "third")` 。
    * **方法二**: 在创建向量时直接命名 。
        * `a <- c(first=1, second=4, third=2)` 。

#### **2.1.3 访问与修改向量元素**
* **访问单个元素**: 使用方括号 `[]` 和索引值来访问向量的特定元素 。
    * `x[i]` 返回向量x的第i个元素 。
    * 如果向量有命名，也可以通过名称来访问，例如 `a["third"]` 。
* **修改单个元素**: 同样使用方括号 `[]` 来修改元素的值 。
    * `a[3] <- 10` 会将向量a的第三个元素修改为10 。
    * 如果指定的索引超出了向量的当前长度，R会自动扩展向量，并在中间填充`NA`（缺失值） 。

#### **2.1.4 向量的子集 (Subsetting)**
* 方括号 `[]` 不仅能访问单个元素，还能用于提取向量的子集 。有三种主要方法：
    1.  **使用正整数索引**: 提供一个包含所需元素索引的向量 。
        * `a[c(1, 2, 3)]` 。
    2.  **使用负整数索引**: 提供一个包含要移除元素索引的向量 。
        * `a[-4]` 。
    3.  **使用逻辑向量**: 提供一个与原向量等长的逻辑向量（`TRUE`/`FALSE`），R会返回所有对应值为`TRUE`的元素 。
        * `a[c(TRUE, TRUE, TRUE, FALSE)]` 。
        * 这个特性在根据条件筛选向量时非常有用，例如 `a[a%%2==0]` 会返回向量a中所有能被2整除的元素 。

#### **2.1.5 向量化计算 (Vectorised Calculations)**
* **元素级运算**: 当对向量使用算术运算符或数学函数时，计算会逐个元素地进行 。
    * 例如 `c <- 2*a + b`，结果向量c的第i个元素等于 `2*a[i] + b[i]` 。
* **循环法则 (Recycling Rule)**:
    * 当两个长度不同的向量进行运算时，R会自动重复（“循环”）较短的向量，直到其长度与较长的向量匹配 。
    * 例如 `c(1,2,3,4) * c(2,0)` 的计算过程是 `c(1,2,3,4) * c(2,0,2,0)` 。
    * **警告**: 如果长向量的长度不是短向量长度的整数倍，R会执行计算但会给出一个警告信息 。这个警告通常意味着代码可能存在错误 。

#### **2.1.6 序列与重复向量**
* **创建序列 (Sequences)**:
    * 使用冒号运算符 `:` 创建简单的整数序列，例如 `2:5` 。
    * 使用 `seq()` 函数创建更复杂的序列 。
        * `seq(from, to, by=...)`：指定步长 。
        * `seq(from, to, length.out=...)`：指定序列的总长度 。
* **创建重复向量 (Repeats)**:
    * 使用 `rep()` 函数来重复向量或其元素。
    * `rep(x, times=n)`: 将整个向量x重复n次 。
    * `rep(x, each=n)`: 将向量x中的每个元素分别重复n次 。

---

### 2.2 R中的矩阵 (Matrices)

#### **2.2.1 矩阵的基本概念**
* 矩阵是向量的二维推广，拥有行和列两个索引 。
* **内部存储**: R在内部以“列主序 (column-major mode)”存储矩阵，即按列将所有元素堆叠成一个长向量 。这与C或Java中的“行主序 (row-major mode)”不同 。

#### **2.2.2 创建矩阵**
* 主要有三种方法可以创建矩阵：
    1.  **使用 `matrix()` 函数**: 这是最直接的方法。通过提供一个数据向量，并指定行数（`nrow`）或列数（`ncol`）来创建 。
    2.  **按行合并 `rbind()`**: 使用 `rbind()` 函数可以将多个向量作为行合并成一个矩阵 。也可以用它给现有矩阵增加新行 。
    3.  **按列合并 `cbind()`**: 与 `rbind()` 类似，`cbind()` 将多个向量作为列合并成一个矩阵 。

#### **2.2.3 矩阵维度与命名**
* **获取维度**:
    * `nrow(B)`: 获取矩阵B的行数 。
    * `ncol(B)`: 获取矩阵B的列数 。
    * `dim(B)`: 以向量形式返回矩阵B的维度（行数, 列数） 。
    * `length(B)`: 返回矩阵B中元素的总数 。
* **命名行列**:
    * 使用 `rownames()` 和 `colnames()` 函数可以为矩阵的行和列命名 。这使得代码更具可读性 。

#### **2.2.4 访问与修改矩阵元素**
* **访问单个元素**: 使用 `B[row, col]` 的形式来访问或修改特定位置的元素 。
* **访问子矩阵**:
    * 可以通过在方括号中提供行和列的索引向量来提取任意子矩阵 。例如 `B[1, 1:2]` 。
    * 若要选择整行或整列，可以将对应的维度留空。例如 `B[1,]` 提取第一行 ，`B[,3]` 提取第三列 。
* **`drop=FALSE` 参数**: 当提取的子矩阵仅有一行或一列时，R默认会将其简化为向量 。为防止这种情况发生，可以添加 `drop=FALSE` 参数 。
* **逻辑索引**: 与向量类似，也可以使用逻辑表达式来筛选和修改矩阵元素 。例如，`B[B > 5] <- 6` 会将矩阵B中所有大于5的元素替换为6 。

---

### 2.3. 矩阵运算与线性代数

#### **2.3.1 矩阵乘法**
* **元素级乘法**: 普通的 `*` 运算符用于矩阵时，执行的是元素对元素的乘法 。
* **矩阵乘法**: 要执行标准的矩阵乘法，必须使用 `%*%` 运算符 。

#### **2.3.2 常用线性代数函数**
* **转置 (Transpose)**: 使用 `t(A)` 函数计算矩阵A的转置 ($A^{\top}$) 。
* **叉乘 (Cross Product)**: 使用 `crossprod(A)` 可以高效地计算 $A^{\top}A$ 。
* **矩阵求逆 (Inverse)**: `solve(C)` 用于计算方阵C的逆矩阵 。
* **解线性方程组**:
    * `solve(A, b)` 用于求解形如 $Az=b$ 的线性方程组 。
    * 这种方法比先计算逆矩阵再相乘（`solve(A) %*% b`）效率更高 。

#### **2.3.3 矩阵分解**
* **Choleski分解**:
    * 对于对称正定矩阵A，可以将其分解为 $A = LL^T$，其中L是一个下三角矩阵 。
    * 在R中，使用 `chol()` 函数进行计算 。
* **特征值与特征向量 (Eigenvalues & Eigenvectors)**:
    * `eigen(A)` 函数用于计算方阵A的特征值和特征向量 。
    * 返回结果是一个列表，其中 `$values` 存储特征值，`$vectors` 存储对应的特征向量 。


### 3.1. R中的更多数据类型

#### **3.1.1 字符字符串 (Character Strings)**
* **定义**: 在R中，可以使用双引号 `"` 或单引号 `'` 来定义字符串 。
* **打印**:
    * 直接使用变量名或 `print()` 函数会显示字符串的引用格式（带引号） 。
    * 使用 `cat()` 函数可以打印字符串的原始内容，不带引号 。
* **操作**:
    * R有多种内置函数用于操作字符串，但使用 `stringr` 包中的函数通常更简单 。
    * 可以使用 `str_c()` (来自 `stringr` 包) 或 `paste()` (基础R函数) 来连接两个字符串 。
* **限制与比较**:
    * 不能对字符向量进行任何算术运算（如加法），否则会报错 。
    * 字符串之间的比较是基于**词典顺序 (lexicographic ordering)** 。例如，`"apple" > "pear"` 的结果是 `FALSE` 。
    * 这种比较方式在处理包含数字的字符串时可能会产生意外结果，例如 `"120" > "5"` 的结果是 `FALSE`，因为在词典顺序中，"120" 是以 "1" 开头，排在以 "5" 开头的字符串之前 。

#### **3.1.2 因子 (Factors)**
* **定义**: 因子是为分类变量设计的特殊数据类型 。与字符向量的主要区别在于，因子的值只能是预先定义好的一组**水平 (levels)** 。
* **创建**: 可以使用 `factor()` 函数将任何向量转换为因子 。该函数可以接受 `levels` 和 `labels` 参数来设置允许的值和它们在显示时对应的标签 。
* **修改**:
    * 你可以将因子的元素修改为任何一个已存在的水平值 。
    * 你不能将元素修改为一个不存在的水平值，这样做会产生一个警告，并且该元素会被设置为 `NA` 。
    * 要添加新的可允许值，必须先使用 `levels()` 函数扩展水平集 。
* **转换**: 使用 `unclass()` 函数可以将因子转换回其原始的数值格式（即其内部存储的整数代码） 。

#### **3.1.3 数据类型转换与缺失值**
* **类型转换**: 可以使用 `as.<目标类型>()` 格式的函数在不同数据类型之间进行转换，例如 `as.numeric()`, `as.character()` 等 。
* **缺失值 (NA)**:
    * R使用特殊值 `NA` 来表示缺失的数据 。它不同于 `NaN` ("Not a Number")，`NaN` 通常是计算出错的结果 。
    * 任何涉及 `NA` 的计算，其结果通常也是 `NA` 。
    * 要在计算中忽略 `NA`，可以使用 `na.omit()` 函数移除所有NA值，或者在支持的函数（如 `mean()`）中使用 `na.rm=TRUE` 参数 。
    * **检测缺失值**: 必须使用 `is.na()` 函数来检测一个值是否为 `NA` 。不能使用 `== NA` 来进行判断，因为这种比较的结果只会是 `NA` 。

---

### 3.2. 列表 (Lists)

* **创建**: 使用 `list()` 命令可以创建一个列表 。列表非常灵活，它的元素可以是任何数据类型（如向量、矩阵、甚至其他列表），并且每个元素的长度可以不同 。
* **命名**: 良好的编程习惯是为列表的元素命名 。可以通过 `names()` 函数或在创建列表时直接命名 。
* **访问元素**:
    * **提取单个元素本身**: 使用双重方括号 `[[...]]` 或美元符号 `$` 。例如 `example1[[1]]` 和 `example1$a` 都返回列表的第一个元素 。
    * **提取子列表**: 使用单重方括号 `[...]` 。这会返回一个**新的列表**，其中包含你指定的元素 。例如 `example1[1]` 返回一个只包含第一个元素的列表，而不是第一个元素本身 。
* **普遍性**: 列表在R中无处不在，许多R函数的返回值就是列表 。例如，线性模型函数 `lm()` 的返回对象 `fit` 就是一个包含系数、残差等多个组件的列表 。

---

### 3.3. 数据框 (Data Frames)

#### **3.3.1 数据框基础**
* **必要性**: 矩阵要求所有元素必须是相同的数据类型 。如果将一个字符型列（如性别）添加到一个数值型矩阵中，R会将所有数值强制转换为字符，这会导致后续的数值比较和计算出错 。数据框就是为了解决这个问题而设计的，它允许不同列包含不同的数据类型 。
* **创建**:
    * 可以使用 `data.frame()` 函数直接创建 。
    * 可以使用 `as.data.frame()` 将一个矩阵转换为数据框 。
* **双重特性**: 数据框既像矩阵，又像列表 。
    * **像矩阵**: 拥有行名和列名，可以使用 `[行, 列]` 的语法进行子集选择 。
    * **像列表**: 每一列可以看作是列表的一个元素，因此可以使用 `$` 或 `[[...]]` 来访问单个列 。例如，`kids$age`, `kids[,"age"]`, 和 `kids[["age"]]` 都是等效的 。

#### **3.3.2 数据框操作**
* **添加/转换列**:
    * 可以使用 `cbind()` 或直接用 `$` 赋值来添加新列 。
    * 推荐使用 `transform()` 函数，它的语法更简洁，可以避免在代码中重复写数据框的名称 。
* **删除列**:
    * 可以使用矩阵风格的负索引，例如 `chol[,-3]` 。
    * 可以使用列表风格的赋值，将要删除的列赋值为 `NULL`，例如 `chol$trig <- NULL` 。
* **子集筛选 (行)**:
    * 可以使用矩阵风格的逻辑索引，例如 `chol[chol$smoke!="no",]` 。但如果条件中包含 `NA`，结果中会产生整行为 `NA` 的行 。
    * 推荐使用 `subset()` 函数，它的语法更清晰，并且能正确处理 `NA` 值，不会在结果中产生 `NA` 行 。
* **排序**:
    * 要对整个数据框按某一列进行排序，不能直接用 `sort()` 。
    * 应使用 `order()` 函数获取排序所需的索引排列，然后将这个排列应用到数据框的行上 。例如: `chol[order(chol$age),]` 。

#### **3.3.3 数据框管理**
* **`attach()` 函数**:
    * `attach(df)` 可以将一个数据框的列加载到当前工作环境中，这样就可以直接通过列名访问，无需再写 `df$` 。
    * **危险**: `attach()` 创建的是数据的**副本**，而不是链接 。如果你修改了这个副本变量，原始数据框中的数据**不会**改变，这会导致数据不一致，极易引发错误 。
    * **建议**: 最好避免使用 `attach()` 。如果一定要用，请记住：**绝不要修改被 attach 的数据！** 。
* **`merge()` 函数**:
    * 用于根据一个或多个公共的键（key）来合并两个数据框 。
    * 默认情况下，`merge` 会使用两个数据框中共有的列名作为键 。
    * 最佳实践是使用 `by` 参数明确指定用于合并的键 。
    * 可以使用 `all.x=TRUE` 或 `all.y=TRUE` 来保留其中一个数据框的所有记录（类似于SQL中的左连接或右连接） 。

---

### 3.4. 数据的导入与导出

#### **3.4.1 R原生数据格式 (.RData)**
* **优点**: `.RData` 文件是R的内部二进制格式，能精确地存储R对象，加载后能保证数据被完全复现 。
* **函数**:
    * `save(x, file="...")`: 保存一个或多个对象 。
    * `save.image(file="...")`: 保存整个工作空间的所有对象 。
    * `load(file="...")`: 加载 `.RData` 文件 。

#### **3.4.2 文本文件和CSV文件**
* **读取前的准备**: 在读取文本文件前，最好先用文本编辑器打开它，确认以下信息 ：
    * **列名 (Header)**: 第一行是数据还是列名？ 
    * **分隔符 (Delimiter)**: 列与列之间用什么字符分隔（如空格、逗号、制表符等）？ 
    * **缺失值编码**: 缺失值是如何表示的（如 `NA`, `.` , `*` 等）？ 
* **读取函数**:
    * `read.table()`: 用于读取通用格式的文本文件 。它有几个重要参数：
        * `header=TRUE`: 如果第一行是列名 。
        * `sep="..."`: 指定分隔符，如 `sep=","` 。
        * `na.strings="..."`: 指定代表缺失值的字符串 。
    * `read.csv()`: `read.table` 的一个特例，默认设置了 `header=TRUE` 和 `sep=","`，专门用于读取CSV文件 。
* **读取后的检查**:
    * 数据读入后，务必使用 `head()` 查看前几行，确保数据格式正确 。
    * 使用 `sapply(df, class)` 或 `str(df)` 检查每一列的数据类型是否符合预期 。
* **导出函数**:
    * `write.table()`: 将数据框写入文本文件 。
    * `write.csv()`: 将数据框写入CSV文件 。

#### **3.4.3 其他文件格式**
* 有许多R包可以用来读取其他软件（如Excel, SPSS, Stata）的文件格式 。
* 常用包包括 `readxl` (用于.xls和.xlsx) 和 `foreign` (用于SPSS, Stata) 。